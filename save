const express = require("express");
const path = require("path");
const sqlite3 = require("sqlite3").verbose();
const bcrypt = require('bcrypt');
const app = express();

// Middleware
app.use(express.static(path.join(__dirname, "public")));
app.use(express.json());

// Connect to SQLite database
const db = new sqlite3.Database(path.join(__dirname, ".database", "database.db"), sqlite3.OPEN_READWRITE, (err) => {
    if (err) {
        console.error("‚ùå Failed to connect to database:", err.message);
    } else {
        console.log("‚úÖ Connected to SQLite database.");
    }
});

app.get('/quests', (req, res) => {
    db.all(`SELECT quest_id, title, description, points FROM Quests`, [], (err, rows) => {
        if (err) {
            console.error("‚ùå Error fetching quests:", err.message);
            return res.status(500).json({ error: "Database error" });
        }
        res.json(rows);
    });
});

// Routes
app.get("/", (req, res) => {
    res.sendFile(path.join(__dirname, "public", "index.html"));
});

app.get("/leaderboard.html", (req, res) => {
    res.sendFile(path.join(__dirname, "public", "leaderboard.html"));
});

app.get("/leaderboard", (req, res) => {
    db.all(`SELECT name, total_points FROM Guilds ORDER BY total_points DESC`, [], (err, rows) => {
        if (err) {
            console.error("DB error:", err.message);
            return res.status(500).json({ error: err.message });
        }
        res.json(rows);
    });
});

app.get('/quests', (req, res) => {
    db.all(`SELECT quest_id, title, description, points FROM Quests`, [], (err, rows) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(rows);
    });
});

app.post('/complete-quest', (req, res) => {
    const { user_id, quest_id } = req.body;

    // Step 1: Get quest point value
    db.get(`SELECT points FROM Quests WHERE quest_id = ?`, [quest_id], (err, quest) => {
        if (err || !quest) return res.status(400).json({ error: "Invalid quest" });

        const points = quest.points;
        const date_completed = new Date().toISOString();

        // Step 2: Insert into PointLogger
        db.run(`INSERT INTO PointLogger (user_id, quest_id, points_earned, date_completed)
                VALUES (?, ?, ?, ?)`, [user_id, quest_id, points, date_completed], function(err) {

            if (err) return res.status(500).json({ error: "Failed to log completion" });

            // Step 3: Update user's personal points
            db.run(`UPDATE Users SET points = points + ? WHERE user_id = ?`,
                [points, user_id], function(err) {
                if (err) return res.status(500).json({ error: "Failed to update user points" });

                // Step 4: Get user's guild
                db.get(`SELECT guild_id FROM Users WHERE user_id = ?`, [user_id], (err, userRow) => {
                    if (err || !userRow) return res.status(500).json({ error: "User not found" });

                    // Step 5: Update guild's points
                    db.run(`UPDATE Guilds SET total_points = total_points + ? WHERE guild_id = ?`,
                        [points, userRow.guild_id], function(err) {
                        if (err) return res.status(500).json({ error: "Failed to update guild points" });

                        // ‚úÖ All done!
                        res.json({ message: "Quest completed successfully", pointsEarned: points });
                    });
                });
            });
        });
    });
});

app.post('/complete-quest', (req, res) => {
    const { user_id, quest_id, points } = req.body;

    if (!user_id || !quest_id || !points) {
        return res.status(400).json({ error: "Missing required fields" });
    }

    // Check if quest was already completed
    db.get(`SELECT * FROM QuestCompletions WHERE user_id = ? AND quest_id = ?`, [user_id, quest_id], (err, row) => {
        if (row) {
            return res.status(400).json({ error: "Quest already completed" });
        }

        db.serialize(() => {
            // 1. Log the quest
            db.run(`INSERT INTO QuestCompletions (user_id, quest_id) VALUES (?, ?)`, [user_id, quest_id]);

            // 2. Update user points
            db.run(`UPDATE Users SET points = points + ? WHERE user_id = ?`, [points, user_id]);

            // 3. Update guild points
            db.get(`SELECT guild_id FROM Users WHERE user_id = ?`, [user_id], (err, row) => {
                if (row) {
                    db.run(`UPDATE Guilds SET total_points = total_points + ? WHERE guild_id = ?`, [points, row.guild_id]);
                }
            });

            res.json({ success: true });
        });
    });
});

app.get('/quests', (req, res) => {
    db.all(`SELECT quest_id, title, points, description FROM Quests`, [], (err, rows) => {
        if (err) {
            console.error(err.message);
            return res.status(500).json({ error: "Database error" });
        }
        res.json(rows);
    });
});

// const bcrypt = require('bcrypt'); // Install with: npm install bcryptserver


app.post('/register', (req, res) => {
    const { email, first_name, last_name, password, is_admin, guild_id } = req.body;

    if (!email || !first_name || !last_name || !password || guild_id == null || is_admin == null) {
        return res.status(400).json({ success: false, error: "Missing required fields" });
    }

    // Step 1: Check if email already exists
    db.get(`SELECT * FROM Users WHERE email = ?`, [email], (err, user) => {
        if (err) return res.status(500).json({ success: false, error: "Database error" });
        if (user) return res.status(400).json({ success: false, error: "Email already registered" });

        // Step 2: Hash password
        bcrypt.hash(password, 10, (err, hash) => {
            if (err) return res.status(500).json({ success: false, error: "Error hashing password" });

            // Step 3: Insert user
            db.run(`
                INSERT INTO Users (email, first_name, last_name, password, is_admin, guild_id, total_points)
                VALUES (?, ?, ?, ?, ?, ?, 0)
            `,
            [email, first_name, last_name, hash, is_admin, guild_id],
            function (err) {
                if (err) return res.status(500).json({ success: false, error: "Failed to register user" });
                return res.json({ success: true, user_id: this.lastID });
            });
        });
    });
});

app.post('/login', (req, res) => {
    const { email, password } = req.body;

    db.get(`SELECT * FROM Users WHERE email = ? AND password = ?`, [email, password], (err, row) => {
        if (err) return res.status(500).json({ error: "Database error" });
        if (!row) return res.status(400).json({ error: "Invalid email or password" });

        // If found, return user data (excluding password for safety)
        const user = {
            user_id: row.user_id,
            first_name: row.first_name,
            is_admin: row.is_admin,
            guild_id: row.guild_id
        };
        res.json({ success: true, user });
    });
});

app.post('/login', (req, res) => {
    console.log("Login attempt:", req.body);
    // ...
});

// Start server
const PORT = 8000;
app.listen(PORT, () => {
    console.log(`üöÄ Server running at http://localhost:8000`);
});









document.addEventListener("DOMContentLoaded", async () => {
    const user = JSON.parse(localStorage.getItem("user"));
    const token = localStorage.getItem("token");
    if (!user) {
    window.location.href = "login.html";
    return;
    }

    const bookList = document.getElementById("bookList");
    const voteForm = document.getElementById("voteForm");
    const voteMessage = document.getElementById("voteMessage");
  let poll = null; // declare poll here for later use

    try {
    const res = await fetch("/api/active-poll");
    const data = await res.json();
    console.log("Fetched poll data:", data);


    if (!data || !data.books || data.books.length === 0) {
    voteMessage.textContent = "‚ùå No active poll available.";
    return;
}

poll = {
    poll_id: data.poll_id,
    title: data.title,
    description: data.description
};
    document.querySelector("h2").textContent = data.title;

    data.books.forEach(book => {
        const card = document.createElement("div");
        card.className = "book-card";

        const radio = document.createElement("input");
        radio.type = "radio";
        radio.name = "book_id";
        radio.value = book.book_id;
        radio.id = `book-${book.book_id}`;

        const label = document.createElement("label");
        label.setAttribute("for", `book-${book.book_id}`);
        label.className = "vote-btn";
        label.innerHTML = `
        <img src="${book.cover_url}" alt="${book.title}" />
        <h3>${book.title}</h3>
        <p><em>by ${book.author}</em></p>
        <p>${book.description}</p>
        `;

        card.appendChild(radio);
        card.appendChild(label);
        bookList.appendChild(card);
    });
    } catch (err) {
    voteMessage.textContent = "‚ùå Error loading poll data.";
    console.error(err);
    }

    voteForm.addEventListener("submit", async (e) => {
    e.preventDefault();
        if (result.success) {
    voteMessage.textContent = "‚úÖ Vote submitted successfully!";
    await loadResults(poll.poll_id); // show results after voting
}
    async function loadResults(poll_id) {
    try {
        const res = await fetch(`/api/poll-results/${poll_id}`);
        const results = await res.json();

        const resultsList = document.getElementById("resultsList");
        resultsList.innerHTML = "";

        results.forEach(item => {
            const li = document.createElement("li");
            li.textContent = `üìò ${item.title} ‚Äì ${item.votes} vote${item.votes != 1 ? 's' : ''}`;
            resultsList.appendChild(li);
        });
    } catch (err) {
        console.error("Error loading poll results:", err);
    }
}
    const selected = document.querySelector('input[name="book_id"]:checked');
    if (!selected) {
        voteMessage.textContent = "‚ùå Please select a book before voting.";
        return;
    }

    try {
        const voteRes = await fetch("/api/vote", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${token}`  // üîë Send the JWT token
            },
            body: JSON.stringify({
                user_id: user.user_id,
                book_id: selected.value,
                poll_id: poll.poll_id
            })
        });

        const result = await voteRes.json();

        if (!voteRes.ok) {
            voteMessage.textContent = `‚ùå ${result.message || "Vote failed. Already voted."}`;
            return;
        }

        voteMessage.textContent = "‚úÖ Vote submitted successfully!";
    } catch (err) {
        console.error("Error submitting vote:", err);
        voteMessage.textContent = "‚ùå Failed to submit your vote due to a network error.";
    }
})})
async function loadWinner() {
    try {
        const res = await fetch("/api/poll-winner");
        const winner = await res.json();

        const display = document.getElementById("winnerDisplay");
        display.innerHTML = `
            <div class="book-card">
                <img src="${winner.cover_url}" alt="${winner.title}" />
                <h3>${winner.title}</h3>
                <p><em>by ${winner.author}</em></p>
                <p>Votes: ${winner.votes}</p>
            </div>
        `;
    } catch (err) {
        console.error("Error loading poll winner:", err);
        document.getElementById("winnerSection").style.display = "none";
    }
}